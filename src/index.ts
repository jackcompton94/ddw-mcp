import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import { z } from "zod";
import * as dotenv from 'dotenv';
import { fileURLToPath } from "url";
import path from "path";

const __filename = fileURLToPath(import.meta.url);
const envPath = path.join(path.dirname(__filename), '../.env');
dotenv.config({ path: envPath });

const API_KEY = `Bearer ${process.env.DW_AUTH_TOKEN}`;
const API_URL = "https://api.data.world/v0";

const server = new McpServer({
  name: "ddw-mcp",
  version: "1.0.0",
  capabilities: {
    tools: {},
    resources: {},
  },
});

// Query Dataset
server.tool(
  "query-dataset",
  `Execute a SQL query against a data.world dataset.`,
  {
    organization: z.string().describe("Organization that owns the dataset"),
    dataset: z.string().describe("Dataset ID to query"),
    query: z.string().describe("SQL query to execute"),
    includeSchema: z.boolean().optional().default(false).describe("Include table schema in response")
  },
  async ({ organization, dataset, query, includeSchema }) => {
    const url = new URL(`${API_URL}/sql/${organization}/${dataset}`);
    url.searchParams.set("includeTableSchema", includeSchema.toString());
    url.searchParams.set("query", query);

    try {
      const response = await fetch(url.toString(), {
        method: "GET",
        headers: {
          accept: "application/json",
          authorization: API_KEY,
        },
      });

      if (!response.ok) {
        const msg = await response.text();
        return { content: [{ type: "text", text: `Query failed (${response.status}): ${msg}` }] };
      }

      const data = await response.json();
      return {
        content: [{
          type: "text",
          text: JSON.stringify(data, null, 2),
        }],
      };
    } catch (err) {
      return {
        content: [{ type: "text", text: `Network error: ${err instanceof Error ? err.message : String(err)}` }],
      };
    }
  }
);

// List Datasets
server.tool(
  "list-datasets",
  `List datasets in an organization.`,
  {
    organization: z.string().describe("Organization to list datasets from")
  },
  async ({ organization }) => {
    const url = `${API_URL}/datasets/${organization}`;

    try {
      const response = await fetch(url, {
        method: "GET",
        headers: {
          accept: "application/json",
          authorization: API_KEY,
        },
      });

      if (!response.ok) {
        const msg = await response.text();
        return { content: [{ type: "text", text: `Failed to fetch datasets (${response.status}): ${msg}` }] };
      }

      const data = await response.json();
      const datasets = data.records || [];

      return {
        content: [{
          type: "text",
          text: datasets.length > 0
            ? datasets.map((d: { id: string; title: string }) => `${d.id} - ${d.title}`).join('\n')
            : `No datasets found in ${organization}`,
        }],
      };
    } catch (err) {
      return {
        content: [{ type: "text", text: `Network error: ${err instanceof Error ? err.message : String(err)}` }],
      };
    }
  }
);

// Save Insight
server.tool(
  "save-insight",
  `Save a markdown report as an insight in a dataset.`,
  {
    organization: z.string().describe("Organization that owns the dataset"),
    dataset: z.string().describe("Dataset to save insight to"),
    title: z.string().describe("Title of the insight"),
    markdown: z.string().describe("Markdown content to save"),
    includeSignature: z.boolean().optional().default(true).describe("Include 'Generated by MCP Server' signature"),
  },
  async ({ organization, dataset, title, markdown, includeSignature }) => {
    const url = `${API_URL}/insights/${organization}/${dataset}`;
    const signature = includeSignature ? "\n> _This report was generated by the data.world MCP Server._" : "";

    try {
      const response = await fetch(url, {
        method: "POST",
        headers: {
          "Authorization": API_KEY,
          "Content-Type": "application/json",
          "Accept": "application/json",
        },
        body: JSON.stringify({
          title,
          body: { markdownBody: `${markdown}${signature}` },
        }),
      });

      const json = await response.json();

      if (!response.ok) {
        return { content: [{ type: "text", text: `Failed to save insight (${response.status}): ${json.message || 'Unknown error'}` }] };
      }

      return {
        content: [{
          type: "text",
          text: `Insight saved: ${json.uri || '(no link available)'}`,
        }],
      };
    } catch (err) {
      return {
        content: [{ type: "text", text: `Network error: ${err instanceof Error ? err.message : String(err)}` }],
      };
    }
  }
);

// Get Dataset Metadata
server.tool(
  "get-dataset",
  `Retrieve metadata for a dataset.`,
  {
    organization: z.string().describe("Organization that owns the dataset"),
    dataset: z.string().describe("Dataset ID to inspect"),
  },
  async ({ organization, dataset }) => {
    const url = new URL(`${API_URL}/datasets/${organization}/${dataset}`);

    try {
      const response = await fetch(url.toString(), {
        method: "GET",
        headers: {
          accept: "application/json",
          authorization: API_KEY,
        },
      });

      if (!response.ok) {
        const msg = await response.text();
        return { content: [{ type: "text", text: `Failed to retrieve dataset (${response.status}): ${msg}` }] };
      }

      const data = await response.json();

      return {
        content: [{
          type: "text",
          text: JSON.stringify(data, null, 2),
        }],
      };
    } catch (err) {
      return {
        content: [{ type: "text", text: `Network error: ${err instanceof Error ? err.message : String(err)}` }],
      };
    }
  }
);


async function main() {
  const transport = new StdioServerTransport();
  await server.connect(transport);
  console.error("DDW MCP Server running on stdio");
}

main().catch((err) => {
  console.error("Fatal error in main():", err);
  process.exit(1);
});
